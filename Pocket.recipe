#!/usr/bin/env python
# vim:ft=python tabstop=8 expandtab shiftwidth=4 softtabstop=4
from __future__ import print_function

__version__ = "2.7.5"

"""
2.7.5: Remove SECTIONS_BY_DOMAIN_USING_TLD sections functionality that relies on external 'tld' library. Remove
       remnants of TITLE_WITH_TAGS functionality. Modernize code.
2.7.4: Fix #46 KeyError: u'resolved_title'
2.7.3: Replace tld with standard Python way (not as good as tld but works without extra package) if SECTIONS_BY_DOMAIN_USING_TLD = False
2.7.2: Change default MAX_ARTICLES to 30
2.7.1: A fix for import tld
2.7:   Introduce ~/.pocket.py local config system
2.6.4: SECTIONS_BY_DOMAIN, an excellent implementation from @alvaroreig to make sections
       by domains (of URLs) 210322
2.6.3: With fix from @AkashPatel95 #26 201122
2.6.2: Fix. Add also removal of H1 to clean up all titles, to insert a new one

**TAGS** (list of strings or empty list: []) if empty then the plugin will connect to Pocket and fetch articles based on the configuration of the plugin.
        Next, the plugin will get tags of these articles and group them into sections in the final ebook.
        If TAGS has elements, e.g., TAGS = ['tag1', 'tag2'] then only these tags will be fetched from Pocket.

**TAGS_EXCEPTIONS** (list of strings or empty list: []) if [] (empty list) then the plugin will ignore it.
        If TAGS_EXCEPTIONS has elements, e.g., TAGS_EXCEPTIONS = ['tag3', 'tag4'] then the articles tagged with these tags will be ignored.
        That is, tag3 and tag4 won't appear as sections, and their articles won't appear in the "Untagged" section.
        This variable is meant to be used with TAGS = [], as it doesn't make any sense to specify a tag both in TAGS and in TAGS_EXCEPTIONS.

**URL_KEYWORD_EXCEPTIONS** (list of keywords such as, if the URL of the article contains any keyword, then the plugin will ignore the article)

**SECTIONS_BY_DOMAIN** (True or False) If True, the articles will be grouped by first level domain. This will override any
        tag configuration (that is: TAGS, TAGS_EXCEPTIONS, INCLUDE_UNTAGGED). This is because the recipe ignores duplicated
        articles, and therefore an article can't appear under a "real" (Pocket) tag and under the fake tag with its domain.

**INCLUDE_UNTAGGED** (True or False) if True then put all fetched and untagged articles in the last section 'Untagged'.
        If False then skip these articles and don't create the section 'Untagged'. Bear in mind that if TAGS is populated ( e.g. TAGS = ['tag1', 'tag2']),
        INCLUDE_UNTAGED = True and other tags exist in Pokcet (e.g. tag3,tag4) then the Untagged section will include untagged articles
        in Pocket AND articles tagged with tag3 and tag4. That behavior can be avoided using TAGS_EXCEPTION

**ARCHIVE_DOWNLOADED** (True or False) do you want to archive articles after fetching

**MAX_ARTICLES** (number) how many articles do you want to fetch in total

**SORT_METHOD** ('oldest' or 'newest') way how the articles are sorted

**OLDEST_ARTICLE** (number) fetch articles added (modified) in Pocket for number of days, 7 will give you articles added/modified in Pocket for the last week

**TO_PULL** ('all' or 'unread') What articles to pull? unread only or all?

**ALLOW_DUPLICATES** (True or False) if True articles that have multiple tags matching those defined in TAGS are duplicated in each matched tag
        Eg.: TAGS = ['tag1','tag2'] then article1 that has both tags will appear in both sections tag1 and tag2.
"""
# CONFIGURATION ###########################################################
TAGS = []  # [] or ['tag1', 'tag2']
TAGS_EXCEPTIONS = []  # [] or ['tag3', 'tag4']
URL_KEYWORD_EXCEPTIONS = []  # [] or ['keyword1', 'keyword2']
SECTIONS_BY_DOMAIN = False
INCLUDE_UNTAGGED = True
ARCHIVE_DOWNLOADED = True
MAX_ARTICLES = 1000
OLDEST_ARTICLE = 365
SORT_METHOD = "newest"
SORT_WITHIN_TAG_BY_TITLE = False
TO_PULL = "unread"
ALLOW_DUPLICATES = True
USE_GLOBAL_CONFIG = False
# NO NEED TO MODIFY ANYTHING BELOW THIS LINE
#############################################################################

# code for configuration set in your home folder
if USE_GLOBAL_CONFIG:
    import os

    try:
        # variables as Python code into ~/.pocket.py to overwrite variables above, e.g.:
        user_path = os.path.expanduser("~")
        exec(open(user_path + "/.pocket.py").read())  # python3
    except:  # FileNotFoundError: noooot perfect!
        pass

import collections
import errno
import json
import sys
from os import path
from time import strftime, time
from urllib.parse import urlparse

try:
    from urllib.error import HTTPError
except ImportError:
    from urllib2 import HTTPError

import mechanize

from calibre.constants import config_dir
from calibre.web.feeds.news import BasicNewsRecipe

__license__ = "GPL v3"
__copyright__ = "2019, David Orchard"


class PocketConfig:
    __file_path = path.join(config_dir, "custom_recipes", "Pocket.json")

    class AuthState:
        FirstRun = 1
        Authorizing = 2
        Authorized = 3

    def __init__(self, state=AuthState.FirstRun, token=None, user=None):
        # Default values
        self.state = state
        self.token = token
        self.user = user

    @staticmethod
    def from_file():
        config = PocketConfig()
        config.load()
        return config

    def load(self):
        try:
            with open(self.__file_path) as config:
                config = json.load(config)

            if isinstance(config, dict):
                for key in self.__dict__.keys():
                    if config.get(key):
                        setattr(self, key, config[key])
        except IOError as e:
            # File not found
            if e.errno != errno.ENOENT:
                raise e

    def save(self):
        with open(self.__file_path, "w") as config:
            json.dump(self.__dict__, config)


class Pocket(BasicNewsRecipe):
    config = PocketConfig.from_file()

    __author__ = "David Orchard"
    description = """

                Modified by Marcin Magnus.

                Fetches articles saved with <a href="https://getpocket.com/">Pocket</a> and archives them.<br>
        """ + (
        """
                Click <a href="https://getpocket.com/connected_applications">here</a>
                to disconnect Calibre from the Pocket account "{}".
        """.format(
            config.user
        )
        if config.user
        else """
                Run 'Fetch News' with this source scheduled to initiate authentication with Pocket.
        """
    )
    publisher = "Pocket.com"
    category = "info, custom, Pocket"

    # User-configurable settings -----------------------------------------------
    tagsList = TAGS
    oldest_article = OLDEST_ARTICLE
    max_articles = MAX_ARTICLES
    archive_downloaded = ARCHIVE_DOWNLOADED
    include_untagged = INCLUDE_UNTAGGED
    series_name = "Pocket"
    sort_method = SORT_METHOD
    to_pull = TO_PULL

    publication_type = "magazine"
    title = "Pocket"
    # timefmt = '' # uncomment to remove date from the filenames, if commented then you will get something like `Pocket [Wed, 13 May 2020]`
    masthead_url = "https://github.com/mmagnus/Pocket-Plus-Calibre-Plugin/raw/master/doc/masthead.png"
    # will make square cover; this will replace text and cover of the default
    # cover_url = "https://github.com/mmagnus/Pocket-Plus-Calibre-Plugin/raw/master/doc/cover.png"
    # --------------------------------------------------------------------------

    # Inherited developer settings
    auto_cleanup = True
    no_stylesheets = True
    use_embedded_content = False
    if ALLOW_DUPLICATES:
        ignore_duplicate_articles = None
    else:
        ignore_duplicate_articles = {"url"}

    # Custom developer settings
    consumer_key = "87006-2ecad30a91903f54baf0ee05"
    redirect_uri = "https://calibre-ebook.com/"
    base_url = "https://getpocket.com"
    to_archive = []

    simultaneous_downloads = 10

    extra_css = ".touchscreen_navbar { display: none; }"
    extra_css = ".calibre_navbar { visibility: hidden; }"

    def pocket_api_request(self, endpoint, request_dict):
        req_dict = {"consumer_key": self.consumer_key}
        req_dict.update(request_dict)
        return mechanize.Request(
            self.base_url + endpoint,
            json.dumps(req_dict),
            headers={
                "Content-Type": "application/json; charset=UTF8",
                "X-Accept": "application/json",
            },
        )

    def first_run(self):
        request = self.pocket_api_request(
            "/v3/oauth/request", {"redirect_uri": self.redirect_uri}
        )
        response = self.browser.open(request)
        response = json.load(response)
        self.config = PocketConfig(
            state=PocketConfig.AuthState.Authorizing, token=response["code"]
        )

    def authorize(self):
        assert (
            self.config.state == PocketConfig.AuthState.Authorizing
        ), "Authorization process not yet begun"
        assert self.config.token, "No request token"
        request = self.pocket_api_request(
            "/v3/oauth/authorize", {"code": self.config.token}
        )
        try:
            response = self.browser.open(request)
            response = json.load(response)
            self.config = PocketConfig(
                state=PocketConfig.AuthState.Authorized,
                token=response["access_token"],
                user=response["username"],
            )
        except HTTPError as e:
            if e.code == 403:
                # The code has already been used, or the user denied access
                self.reauthorize()
            raise e

    def parse_index(self):
        assert (
            self.config.state == PocketConfig.AuthState.Authorized
        ), "Not yet authorized"
        assert self.config.token, "No access token"

        articles = []
        # dictionary with the sections and its articles. the sections
        # cant be domains or tags depending on SECTIONS_BY_DOMAIN
        section_dict = collections.defaultdict(list)

        ############ GET ALL ITEMS #############
        # get every item and iterate them. Build the section_dict
        # with tags or domains as keys, depending on SECTIONS_BY_DOMAIN
        request = self.pocket_api_request(
            "/v3/get",
            {
                "access_token": self.config.token,
                "count": self.max_articles * 1000,  # something "unlimited"
                "since": int(time()) - 86400 * self.oldest_article,
                "state": self.to_pull,
                "detailType": "complete",
                "sort": self.sort_method,
            },
        )

        try:
            response = self.browser.open(request)
            response = json.load(response)
        except HTTPError as e:
            if e.code == 401:
                # Calibre access has been removed
                self.reauthorize()
            raise e

        if not response["list"]:
            self.abort_recipe_processing(
                'No unread articles in the Pocket account "{}"'.format(self.config.user)
            )
        else:
            for item_id, item in response["list"]:
                if item["status"] == "2":  # status 2 is Should be deleted
                    del response["list"][item_id]
                # If the URL contains any URL_KEYWORD_EXCEPTIONS, ignore article
                elif any(
                    pattern in item["given_url"]
                    for pattern in URL_KEYWORD_EXCEPTIONS
                ):
                    print("Ignoring article due to keyword patterns: {}".format(item["given_url"]))
                    del response["list"][item_id]
                elif SECTIONS_BY_DOMAIN:
                    # the keys of section_dict will be domains
                    # Extract domain from the URL
                    domain = urlparse(item["resolved_url"]).netloc.replace("www.", "")

                    url = item["resolved_url"]
                    print(">> url", url, file=sys.stderr)
                    print(">>> domain", domain, file=sys.stderr)

                    # Add the article ID under its domain
                    section_dict[domain].append(item_id)
                else:
                    # the keys of section_dict will be tags
                    try:
                        tags = list(item["tags"].keys())
                    except KeyError:
                        if self.include_untagged:
                            tags = ["Untagged"]
                        else:
                            tags = None

                    # tags could be None if article untagged and INCLUDE_UNTAGGED=False
                    if tags and not any(
                        tag in TAGS_EXCEPTIONS for tag in tags
                    ):
                        if not TAGS:
                            # autotags enabled, insert tag and item
                            for tag in tags:
                                section_dict[tag].append(item_id)
                        else:
                            # explicit tags, check that the tag belongs to the explicit
                            # array TAGS OR is is an untagged article and
                            # INCLUDE_UNTAGGED=True
                            for tag in tags:
                                if tag in TAGS or (
                                    tag == "Untagged" and self.include_untagged
                                ):
                                    section_dict[tag].append(item_id)

            ############ APPEND ARTS FOR EACH TAG/DOMAIN #############
            # At this point the section_dict is completed, either with
            # domains or with tags

            for section in section_dict:
                arts = []
                for item in section_dict[section]:
                    try:
                        title = response["list"][item]["resolved_title"]
                    except KeyError:
                        title = "error: title"
                    try:
                        url = response["list"][item]["resolved_url"]
                    except KeyError:
                        url = "error: url"
                    try:
                        desc = response["list"][item]["excerpt"]
                    except KeyError:
                        desc = "error: description"
                    arts.append(
                        {
                            "title": title,
                            "url": url,
                            "date": response["list"][item]["time_added"],
                            "description": desc,
                        }
                    )

                    if (
                        self.archive_downloaded
                        and response["list"][item]["item_id"] not in self.to_archive
                    ):
                        self.to_archive.append(response["list"][item]["item_id"])

                if not SECTIONS_BY_DOMAIN and SORT_WITHIN_TAG_BY_TITLE:
                    arts = sorted(arts, key=lambda i: i["title"])

                if arts:
                    articles.append((section, arts))

            if not articles:
                self.abort_recipe_processing(
                    "No articles in the Pocket account {} to download".format(
                        self.config.user
                    )
                )  # , ' '.join(self.tags))) \n[tags: %s]
            return articles

    def reauthorize(self):
        self.config = PocketConfig()
        self.ensure_authorization()

    def ensure_authorization(self):
        if self.config.state == PocketConfig.AuthState.FirstRun:
            self.first_run()
            self.config.save()
            self.abort_recipe_processing(
                """
                                Calibre must be granted access to your Pocket account. Please click
                                <a href="https://getpocket.com/auth/authorize?request_token={0}&redirect_uri={1}">here</a>
                                to authenticate via a browser, and then re-fetch the news.
                        """.format(
                    self.config.token, self.redirect_uri
                )
            )
        elif self.config.state == PocketConfig.AuthState.Authorizing:
            self.authorize()
            self.config.save()

    def get_browser(self, *args, **kwargs):
        self.browser = super().get_browser()
        self.ensure_authorization()
        return self.browser

    def archive(self):
        assert (
            self.config.state == PocketConfig.AuthState.Authorized
        ), "Not yet authorized"
        assert self.config.token, "No access token"

        if not self.to_archive:
            return

        archived_time = int(time())
        request = self.pocket_api_request(
            "/v3/send",
            {
                "access_token": self.config.token,
                "actions": [
                    {
                        "action": "archive",
                        "item_id": item_id,
                        "time": archived_time,
                    }
                    for item_id in self.to_archive
                ],
            },
        )
        response = self.browser.open(request)

    def cleanup(self):
        # If we're in another state, then downloading didn't complete
        # (e.g. reauthorization needed) so there is no archiving to do
        if self.config.state == PocketConfig.AuthState.Authorized:
            self.archive()

    # TODO: This works with EPUB, but not mobi/azw3
    # BUG: https://bugs.launchpad.net/calibre/+bug/1838486
    def postprocess_book(self, oeb, opts, log):
        oeb.metadata.add("series", self.series_name)

    def postprocess_html(self, soup, first):
        title = soup.find("title").text  # get title

        h1s = soup.findAll("h1")  # get all h1 headers
        for h1 in h1s:
            if title in h1.text:
                h1 = h1.clear()  # clean this tag, so the h1 will be there only

        h2s = soup.findAll("h2")  # get all h2 headers
        for h2 in h2s:
            if title in h2.text:
                h2 = h2.clear()  # clean this tag, so the h1 will be there only

        body = soup.find("body")
        new_tag = soup.new_tag("h1")
        new_tag.append(title)
        body.insert(0, new_tag)
        # print(soup.prettify(), file=sys.stderr)
        return soup

    def default_cover(self, cover_file):
        """
        Create a generic cover for recipes that don't have a cover.
        We override this public method to add the time to the cover
        """
        try:
            from calibre import preferred_encoding
            from calibre.ebooks.covers import create_cover

            title = (
                self.title
                if isinstance(self.title, str)
                else self.title.decode(preferred_encoding, "replace")
            )
            # print('>> title', title, file=sys.stderr)
            date = strftime(self.timefmt).replace("[", "").replace("]", "")
            time = strftime("%a %d %b %Y %-H:%M")
            img_data = create_cover(title, [date], series=time)
            cover_file.write(img_data)
            cover_file.flush()
        except:
            self.log.exception("Failed to generate default cover")
            return False
        return True
